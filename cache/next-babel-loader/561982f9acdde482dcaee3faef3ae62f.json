{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component, useState, version } from \"react\";\nimport { Table, Tag, Form, Input, InputNumber, Popconfirm, Row, Col, Dropdown, Progress, DatePicker, Select, Slider, Popover, Button, Modal, Badge } from 'antd';\nimport AddParentRelease from './addParentRelease';\nimport moment from 'moment';\nimport AddChildRelease from \"./addChildRelease\";\nimport ChildReleaseList from \"./ChildReleaseList\";\nimport actions from \"../redux/action\";\nimport { connect } from \"react-redux\";\nimport { MenuOutlined } from '@ant-design/icons';\nimport { statusDisplay, progressDisplay, dateFormat } from \"../commons/helpers\";\nconst {\n  onFetchItem\n} = actions;\n\nclass ReleaseList extends Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"addChildItem\", rec => {\n      this.setState({\n        modalVisible: true,\n        currentRecord: rec\n      });\n    });\n\n    _defineProperty(this, \"deleteItem\", rec => {\n      let arr = JSON.parse(localStorage.getItem(\"parentReleaseData\"));\n      let index = arr.map(x => {\n        return x.key;\n      }).indexOf(rec.key);\n      arr.splice(index, 1);\n      localStorage.setItem('parentReleaseData', JSON.stringify(arr));\n      this.fetchItem();\n    });\n\n    _defineProperty(this, \"EditableCell\", (_ref) => {\n      let {\n        editing,\n        dataIndex,\n        title,\n        inputType,\n        record,\n        index,\n        children\n      } = _ref,\n          restProps = _objectWithoutProperties(_ref, [\"editing\", \"dataIndex\", \"title\", \"inputType\", \"record\", \"index\", \"children\"]);\n\n      let inputNode;\n\n      switch (dataIndex) {\n        case \"version\":\n          inputNode = __jsx(Input, {\n            defaultValue: record.version,\n            name: \"version\",\n            onChange: e => this.handleVersionDesc(e, \"editVersion\")\n          });\n          break;\n\n        case \"startDate\":\n          inputNode = __jsx(DatePicker, {\n            name: \"startDate\",\n            defaultValue: moment(record.startDate, dateFormat),\n            onChange: this.handleStartDate\n          });\n          break;\n\n        case \"endDate\":\n          inputNode = __jsx(DatePicker, {\n            name: \"endDate\",\n            defaultValue: moment(record.endDate, dateFormat),\n            onChange: this.handleEndDate\n          });\n          break;\n\n        case \"description\":\n          inputNode = __jsx(Input, {\n            defaultValue: record.description,\n            onChange: e => this.handleVersionDesc(e, \"editDescription\")\n          });\n          break;\n\n        case \"status\":\n          inputNode = __jsx(Select, {\n            style: {\n              width: 120\n            },\n            name: \"status\",\n            defaultValue: this.state.editStatus,\n            onChange: e => this.handleSelectSlider(e, \"editStatus\")\n          }, __jsx(Option, {\n            value: \"IN PROGRESS\"\n          }, \"In Progress\"), __jsx(Option, {\n            value: \"UNRELEASED\"\n          }, \"Unreleased\"), __jsx(Option, {\n            value: \"RELEASED\"\n          }, \"Released\"));\n          break;\n\n        case \"progress\":\n          inputNode = __jsx(Slider, {\n            defaultValue: this.state.editProgress == \"\" ? 0 : this.state.editProgress,\n            tooltipVisible: true,\n            name: \"progress\",\n            onChange: e => this.handleSelectSlider(e, \"editProgress\")\n          });\n          break;\n      }\n\n      return __jsx(\"td\", restProps, editing ? __jsx(Form.Item, {\n        name: record.key + \"_\" + dataIndex,\n        style: {\n          margin: 0\n        },\n        rules: [{\n          required: true,\n          message: `Please Input ${title}!`\n        }]\n      }, inputNode) : children);\n    });\n\n    _defineProperty(this, \"handleSelectSlider\", (value, type) => {\n      this.setState({\n        [type]: value\n      });\n    });\n\n    _defineProperty(this, \"handleVersionDesc\", (e, type) => {\n      this.setState({\n        [type]: e.target.value\n      });\n    });\n\n    _defineProperty(this, \"handleStartDate\", (date, str) => {\n      this.setState({\n        editstartDate: str\n      });\n    });\n\n    _defineProperty(this, \"handleEndDate\", (date, str) => {\n      this.setState({\n        editEndDate: str\n      });\n    });\n\n    _defineProperty(this, \"isEditing\", record => record.key === this.state.editingKey);\n\n    _defineProperty(this, \"cancel\", () => {\n      this.setState({\n        editingKey: ''\n      });\n    });\n\n    _defineProperty(this, \"handleCancel\", () => {\n      this.setState({\n        modalVisible: false\n      });\n    });\n\n    _defineProperty(this, \"handleOk\", () => {\n      this.setState({\n        modalVisible: false\n      });\n    });\n\n    _defineProperty(this, \"fetchItem\", () => {\n      console.log(\"on fetch item call back\");\n      this.props.onFetchItem();\n    });\n\n    let _this = this;\n\n    this.state = {\n      editingKey: '',\n      editVersion: \"\",\n      editStatus: \"\",\n      editProgress: 0,\n      editstartDate: \"\",\n      editEndDate: \"\",\n      editDescription: \"\",\n      modalVisible: false,\n      currentRecord: {},\n      columns: [{\n        title: 'Version No',\n        dataIndex: 'version',\n        key: 'version',\n        render: text => __jsx(\"a\", null, text),\n        editable: true\n      }, {\n        title: 'Status',\n        dataIndex: 'status',\n        key: 'status',\n        editable: true,\n        render: rec => statusDisplay(rec)\n      }, {\n        title: 'Progress',\n        dataIndex: 'progress',\n        key: 'progress',\n        editable: true,\n        render: rec => progressDisplay(rec)\n      }, {\n        title: 'Start Date',\n        dataIndex: 'startDate',\n        key: 'startDate',\n        editable: true\n      }, {\n        title: 'Release Date',\n        dataIndex: 'endDate',\n        key: 'endDate',\n        editable: true\n      }, {\n        title: 'Description',\n        dataIndex: 'description',\n        key: 'description',\n        editable: true\n      }, {\n        title: 'Action',\n        key: 'action',\n        render: (text, record) => {\n          const editable = this.isEditing(record);\n\n          const Content = __jsx(\"div\", null, __jsx(Row, null, __jsx(Col, {\n            span: 8\n          }, __jsx(\"a\", {\n            disabled: this.state.editingKey !== '',\n            onClick: () => this.edit(record)\n          }, \"Edit\")), __jsx(Col, {\n            span: 8\n          }, __jsx(\"a\", {\n            disabled: this.state.editingKey !== '',\n            onClick: () => this.addChildItem(record)\n          }, \"Add\")), __jsx(Col, {\n            span: 8\n          }, __jsx(\"a\", {\n            disabled: this.state.editingKey !== '',\n            onClick: () => this.deleteItem(record)\n          }, \"Delete\"))));\n\n          return editable ? __jsx(\"span\", null, __jsx(\"a\", {\n            href: \"javascript:;\",\n            onClick: () => this.save(record),\n            style: {\n              marginRight: 8\n            }\n          }, \"Save\"), __jsx(Popconfirm, {\n            title: \"Sure to cancel?\",\n            onConfirm: this.cancel\n          }, __jsx(\"a\", null, \"Cancel\"))) : __jsx(Popover, {\n            content: Content,\n            title: \"Actions\",\n            trigger: \"hover\"\n          }, __jsx(MenuOutlined, null));\n        }\n      }],\n      listDataSrc: [],\n      isEdit: false\n    };\n  }\n\n  componentDidMount() {\n    // let chkItem = JSON.parse(localStorage.getItem(\"parentReleaseData\"));\n    // let getItems = chkItem == null ? [] : chkItem;\n    // this.setState({\n    //     listDataSrc: getItems\n    // })\n    this.fetchItem();\n  }\n\n  componentWillReceiveProps(nextProps) {\n    let {\n      dataFromLS\n    } = nextProps;\n\n    if (dataFromLS) {\n      this.setState({\n        listDataSrc: dataFromLS,\n        editingKey: \"\"\n      });\n    }\n  }\n\n  save(record) {\n    let {\n      editVersion,\n      editstartDate,\n      editEndDate,\n      editDescription,\n      editStatus,\n      editProgress,\n      listDataSrc\n    } = this.state;\n    listDataSrc.map(item => {\n      if (item.key == record.key) {\n        item.key = record.key;\n        item.childRelease = item.childRelease;\n        item.version = editVersion;\n        item.status = editStatus;\n        item.progress = editProgress;\n        item.startDate = editstartDate;\n        item.endDate = editEndDate;\n        item.description = editDescription;\n      }\n    });\n    localStorage.setItem('parentReleaseData', JSON.stringify(listDataSrc));\n    this.setState({\n      editStatus: \"\",\n      editProgress: \"\",\n      editstartDate: \"\",\n      editVersion: \"\",\n      editEndDate: \"\",\n      editDescription: \"\"\n    });\n    this.fetchItem();\n  }\n\n  edit(record) {\n    this.setState({\n      editingKey: record.key,\n      editStatus: record.status,\n      editProgress: record.progress,\n      editstartDate: record.startDate,\n      editVersion: record.version,\n      editEndDate: record.endDate,\n      editDescription: record.description\n    });\n  }\n\n  render() {\n    let {\n      listDataSrc\n    } = this.state;\n    const components = {\n      body: {\n        cell: this.EditableCell\n      }\n    };\n    const columns = this.state.columns.map(col => {\n      if (!col.editable) {\n        return col;\n      }\n\n      return _objectSpread({}, col, {\n        onCell: record => ({\n          record,\n          inputType: col.dataIndex,\n          dataIndex: col.dataIndex,\n          title: col.title,\n          editing: this.isEditing(record)\n        })\n      });\n    });\n    return __jsx(React.Fragment, null, __jsx(Form, null, __jsx(Table, {\n      columns: columns,\n      dataSource: this.props.dataFromLS,\n      components: components,\n      expandable: {\n        expandedRowRender: record => __jsx(ChildReleaseList, {\n          thisData: record,\n          refreshCallBack: this.fetchItem\n        })\n      },\n      rowClassName: \"editable-row\",\n      pagination: {\n        onChange: this.cancel\n      }\n    })), __jsx(AddParentRelease, _extends({}, this.props, {\n      refreshCallBack: this.fetchItem\n    })), __jsx(Modal, {\n      title: \"Add Batch Release\",\n      visible: this.state.modalVisible,\n      onOk: this.handleOk,\n      footer: null,\n      closable: true,\n      className: \"modal-Layout\",\n      onCancel: this.handleCancel\n    }, __jsx(AddChildRelease, {\n      thisData: this.state.currentRecord,\n      closeModal: this.handleOk,\n      dbData: listDataSrc,\n      refreshCallBack: this.fetchItem\n    })));\n  }\n\n}\n\nconst mapStateToProps = state => {\n  return {\n    dataFromLS: state.dataFromLS\n  };\n};\n\nexport default connect(mapStateToProps, {\n  onFetchItem\n})(ReleaseList);","map":null,"metadata":{},"sourceType":"module"}